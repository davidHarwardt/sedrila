# `sedrila`: Tool infrastructure for building and running "self-driven lab" courses

## 1. Overview

## 1.1 What is a self-driven lab course (here known as "a SeDriLa")?

- There is a large number of small tasks, each worth a certain number of work hours
- Within loose constraints, students can pick which tasks they want to work on
- Each task results in a commit in that student's git repository
- At certain times, students can submit a batch of finished tasks to a teaching assistant
- The teaching assistant checks some of the task's solution commits and then
  either accepts or rejects the entire batch.
- If accepted, the work hours those tasks were worth are booked onto the student's workhours account.
- When enough hours have accumulated there, that student has successfully finished the course.

`sedrila` is highly opinionated:
- It assumes that the course content is so useful and motivating to the students
  that they are unlikely to want to cheat.
- It assumes that SeDriLas are (or could become) Open Educational Resources.
  This means that all information that is accessible to the teaching assistants 
  is also accessible to the students.
- It takes a low-tech approach and assumes that content has a simple structure
  because the tasks rely heavily on _external_ materials available on the web.
  The SeDriLa itself has a simple text layout, few images of its own,
  and no local videos or high-tech active content.  
  The idea behind this is to make it realistic to keep the SeDriLa up-to-date over time.


### 1.2 What does the `sedrila` tool do?

It has these functions:

- `build` generates a SeDriLa instance from a SeDriLa template.  
  - The template is a directory tree 
    (maintained in a git repository and developed much like software by the course owners)
    with a prescribed structure that contains all the task descriptions.
  - The instance is a directory tree of static HTML pages.
  - The generation is controlled by a configuration file.
- `evaluate` supports the teaching assistant.
- `howfarami` tells the students how many hours are on their workhours account so far.


## 2. Installation

User installation (not yet implemented):
```
pip install sedrila
```
(Eventually, we will probably want to use a method that results in an executable.)

Developer installation (probably in a fresh venv):
```
git clone git@github.com:fubinf/sedrila.git
cd sedrila
pip install -r requirements.txt
pip install -r requirements-dev.txt
```


## 3. Instructions for course authors

What you need to provide as a course author:
- One plain text file per potential task.
  - That file contains metadata, the task description offered to the students, and
    the instructions for the teaching assistant for this task.
  - The metadata is at the top of the file in Yaml format.
  - The other two parts follow below in Markdown format.
- Tasks are arranged in groups in two levels.
  You need to provide one description file (in Markdown format) for each group: 
  - 'chapters' (typically 3 to 6) form the top level
  - 'taskgroups' (typically 2 to 6 per chapter) form a second level below that [not yet implemented]
- Header and Footer HTML fragments to be used for the rendered HTML pages
  (simple defaults are included)
- A CSS file (a simple default is included)
- One YAML configuration file that specifies the chapters, groups, headers and footers,
  some instructions for task selection etc.


### `sedrila.yaml`: The global configuration file

This is best explained by example:

```
title: "...",
shorttitle: "...",
chapters:
  - title: "...",
    shorttitle: "...",
    directory: "..."
  - title: "...",
    shorttitle: "...",
    directory: "..."
```

The format of the resulting HTML files is determined per page type by the Jinja2 templates
in directory `templates`.


## 4. Instructions for teaching assistants  TODO


## 5. Instructions for students

All instructions are on the course webpages generated by `sedrila`.
Your instructors need to tell you where that lives.
Start there.


# Internal technical notes

## src/*

This will map markdown files present in `content` to html files in the target directory `out` in the same directory structure.
Files that are not markdown files will be copied over.

Be aware that starting files with hyperlinks will confuse the meta data plugin.

Costum made commands:

* `!toc` will create a table of contents up to a depth of 2. It reads the `title` meta data

   You can provide an additional argument to define the target attribute for the generated links.
   If the provided target is #, the links will instead link to anchors.

* `!subtoc` will do that, but only display the part of the table of contents related to this pat

   This will not include items of a depth that are not included in the main table of content.

* `!inline file` will inline the contents of another file.

   This will _not_ create an html file for that file and it will only work in sub-directories

* `!resources` is just a shortcut for `!inline resources.md`

   Ideally, there will be some option to reference links provided in there in some way

* `!overview folder` inlines folder/overview.md and the title links to folder/index.html

   A `target` meta data in the overview file can override the link target.

* `!tasks` will inline all other files in the same folder

Each inline will be wrapped in its own div, containing a class named after their respective command.

In addition, an optional `src/header.html` and `src/footer.html` will be prepended/appended to each produced html file.

You can define alternative header and footer files on a per file basis via the `header` and `footer` meta data. Please note that this will override both, even if only one of them is provided,

### Usage

Running main.py will produce the target directory if missing.

If called with the optional argument `clean`, it will remove that directory beforehand.

If called with the optional argument `test`, it will instead run some unit tests
