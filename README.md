# `sedrila`: Tool infrastructure for building and running "self-driven lab" courses

## 1. Overview

## 1.1 What is a self-driven lab course (here known as "a SeDriLa")?

- There is a large number of small tasks, each worth a certain number of work hours
- Within loose constraints, students can pick which tasks they want to work on
- Each task results in a commit in that student's git repository
- At certain times, students can submit a batch of finished tasks to a teaching assistant
- The teaching assistant checks some of the task's solution commits and then
  either accepts or rejects the entire batch.
- If accepted, the work hours those tasks were worth are booked onto the student's workhours account.
- When enough hours have accumulated there, that student has successfully finished the course.

`sedrila` is highly opinionated:
- It assumes that the course content is so useful and motivating to the students
  that they are unlikely to want to cheat.
- It assumes that SeDriLas are (or could become) Open Educational Resources.
  This means that all information that is accessible to the teaching assistants 
  is also accessible to the students.
- It takes a low-tech approach and assumes that content has a simple structure
  because the tasks rely heavily on _external_ materials available on the web.
  The SeDriLa itself has a simple text layout, few images of its own,
  and no local videos or high-tech active content.  
  The idea behind this is to make it realistic to keep the SeDriLa up-to-date over time.


### 1.2 What does the `sedrila` tool do?

It has these functions (the list is very preliminary):

- `build` generates a SeDriLa instance from a SeDriLa template.  
  - The template is a directory tree 
    (maintained in a git repository and developed much like software by the course owners)
    with a prescribed structure that contains all the task descriptions.
  - The instance is a directory tree of static HTML pages.
  - The generation is controlled by a configuration file.
- `instructor` supports instructors when evaluating student solutions.  TODO 3
- `student` tells the students how many hours are on their workhours account so far.  TODO 2


## 2. Installation

User installation (not yet implemented):
```
pip install sedrila
```
(Eventually, we will probably want to use a method that results in an executable.)

Developer installation (probably in a fresh venv):
```
git clone git@github.com:fubinf/sedrila.git
cd sedrila
pip install -r requirements.txt
pip install -r requirements-dev.txt
source /absolute/path/to/sedrila/cmd/attach_sedrila.bash.inc
sedrila --help
```


## 3. Instructions for course authors

What you need to provide as a course author:
- One plain text file per potential task.
  - That file contains metadata, the task description offered to the students, and
    the instructions for the teaching assistant for this task.
  - The metadata is at the top of the file in Yaml format.
  - The other two parts follow below in Markdown format.
- Tasks are arranged in groups in two levels.
  You need to provide an `index.md` file for each group.
  These are structured like the task files, but with fewer metadata.
  - 'chapters' (typically 3 to 6) form the top level
  - 'taskgroups' (typically 2 to 6 per chapter) form a second level below that
- A central configuration file `sedrila.yaml`, which contains global configuration data,
  global metadata and most metadata for chapters and taskgroups.
- Header and Footer HTML fragments to be used for the rendered HTML pages
  (simple defaults are included).
- A CSS file (a simple default is included).


### 3.1 `sedrila.yaml`: The global configuration file

This is best explained by example:

https://github.com/fubinf/propra-inf/blob/main/sedrila.yaml


### 3.2 Templates for HTML layout

The format of the resulting HTML files is determined per page type by the Jinja2 templates
in directory `templates`.
For examples, see https://github.com/fubinf/propra-inf/tree/main/templates


## 4. Instructions for teaching assistants  TODO


## 5. Instructions for students

All instructions are on the course webpages generated by `sedrila`.
Your instructors need to tell you where that lives.
Start there.


# 6. Internal technical notes

## 6.1 Bookkeeping architecture

In a nutshell, the bookkeeping of _actual_ work hours worked by a student 
and of _"earned value"_ effort hours (called "timevalue") certified by an instructor
is based on the following ideas:

- When students commit a partial or completed task XYZ, they use a prescribed format for the commit message:  
  `XYZ 1:24h  my personal commit message`  
  where `XYZ` is the official name of the task and
  `1:24h` means the student has worked 1 hour and 24 minutes for this commit.
  Decimal fractions (`1.4h`) are possible as well.
- A script can collect, accumulate, and tabulate these actual efforts for the student's information.
  This is also useful to evidence-based improvement of the course contents.
- When students want to show a set of solutions for tasks to an instructor,
  they write the task names to a file `submission.yaml`
- The instructor checks those tasks, adds checking results into that file,
  and commits it. This commmit is cryptographcally signed.
  The commit message says `submission.yaml checked`.
- `course.json` is published along with the webpages.
  It lists all tasks with their dependencies and timevalues
  and all instructors and their public keys.
- The script that computes the "value earned" effort hours uses `course.json` to
  - find all `submission.yaml checked` commits that were made by an instructor
  - extract the list of accepted tasks from them, and
  - tabulate those tasks and compute the total earned value hours for them.
- That script can also tabulate what the instructor did not accept, which makes practical
  a rule that says a task will only count if it gets accepted no later than upon second (or third?) try.


## 6.2 TODO handling

If something is incomplete, add a TODO marker with a priorization digit:
- `TODO 1`: to be completed soon (within a few days)
- `TODO 2`: to be completed once the prio 1 things are done (within days or a few weeks)
- `TODO 3`: to be completed at some later time (usually several weeks or more into the future,
  because it is big) or never (because it is not-so-important: "nice-to-have features")

Add a short description of what needs to be done. Examples:
- `TODO 1: find proper formulation`
- `TODO 2: restructure to use ACME lib`
- `TODO 3: add topological sorting`

If you intend to do it yourself, add your name in parens:  
`TODO 1: find proper formulation (Lutz)`

Then use the IDE global search to work through these layer-by-layer.
Demote items to a lower priority (or remove them) when they become stale.
Kick out prio 3 items when they become unlikely.
