# `sedrila`: Tool infrastructure for building and running "self-driven lab" courses

## 1. Overview

## 1.1 What is a self-driven lab course (here known as "a SeDriLa")?

- There is a large number of small tasks, each worth a certain number of work hours
- Within loose constraints, students can pick which tasks they want to work on
- Each task results in a commit in that student's git repository
- At certain times, students can submit a batch of finished tasks to a teaching assistant
- The teaching assistant checks some of the task's solution commits and then
  either accepts or rejects the entire batch.
- If accepted, the work hours those tasks were worth are booked onto the student's workhours account.
- When enough hours have accumulated there, that student has successfully finished the course.

`sedrila` is highly opinionated:
- It assumes that the course content is so useful and motivating to the students
  that they are unlikely to want to cheat.
- It assumes that SeDriLas are (or could become) Open Educational Resources.
  This means that all information that is accessible to the teaching assistants 
  is also accessible to the students.
- It takes a low-tech approach and assumes that content has a simple structure
  because the tasks rely heavily on _external_ materials available on the web.
  The SeDriLa itself has a simple text layout, few images of its own,
  and no local videos or high-tech active content.  
  The idea behind this is to make it realistic to keep the SeDriLa up-to-date over time.


### 1.2 What does the `sedrila` tool do?

It has these functions:

- `build` generates a SeDriLa instance from a SeDriLa template.  
  - The template is a directory tree 
    (maintained in a git repository and developed much like software by the course owners)
    with a prescribed structure that contains all the task descriptions.
  - The instance is a directory tree of static HTML pages.
  - The generation is controlled by a configuration file.
- `evaluate` supports the teaching assistant.
- `howfarami` tells the students how many hours are on their workhours account so far.


## 2. Installation

User installation (not yet implemented):
```
pip install sedrila
```
(Eventually, we will probably want to use a method that results in an executable.)

Developer installation (probably in a fresh venv):
```
git clone git@github.com:fubinf/sedrila.git
cd sedrila
pip install -r requirements.txt
pip install -r requirements-dev.txt
```


## 3. Instructions for course authors

What you need to provide as a course author:
- One plain text file per potential task.
  - That file contains metadata, the task description offered to the students, and
    the instructions for the teaching assistant for this task.
  - The metadata is at the top of the file in Yaml format.
  - The other two parts follow below in Markdown format.
- Tasks are arranged in groups in two levels.
  You need to provide an `index.md` file for each group.
  These are structured like the task files, but with fewer metadata.
  - 'chapters' (typically 3 to 6) form the top level
  - 'taskgroups' (typically 2 to 6 per chapter) form a second level below that
- A central configuration file `sedrila.yaml`, which contains global configuration data,
  global metadata and most metadata for chapters and taskgroups.
- Header and Footer HTML fragments to be used for the rendered HTML pages
  (simple defaults are included).
- A CSS file (a simple default is included).


### `sedrila.yaml`: The global configuration file

This is best explained by example:

https://github.com/fubinf/propra-inf/blob/main/sedrila.yaml


### Templates for HTML layout

The format of the resulting HTML files is determined per page type by the Jinja2 templates
in directory `templates`.
For examples, see https://github.com/fubinf/propra-inf/tree/main/templates


## 4. Instructions for teaching assistants  TODO


## 5. Instructions for students

All instructions are on the course webpages generated by `sedrila`.
Your instructors need to tell you where that lives.
Start there.


# Internal technical notes

## Bookkeeping architecture

In a nutshell, the bookkeeping of _actual_ work hours worked by a student 
and of _"earned value"_ effort hours accredited by an instructure
is based on the following ideas:

- When students commit a partial or completed task XYZ, they use a prescribed format for the commit message:  
  `XYZ 1:23  my personal commit message`  
  where `XYZ` is the official name of the task and
  `1:23` means the student has worked 1 hour and 23 minutes for this commit.
- A script can collect, accumulate, and tabulate these actual efforts for the student's information.
  This is also useful to evidence-based improvement of the course contents.
- When students want to show a set of solutions for tasks to an instructor,
  they write the task names to a file `to_be_checked.yaml`
- The instructor checks those tasks, adds checking results into that file,
  and commits it. This commmit is cryptographcally signed.
  The commit message says `to_be_checked.yaml checked`.
- `sedrila.yaml` lists all instructors and their public keys.
  This file is published along with the webpages.
- `tasks.yaml` lists the effort values for each task and is also published along with the webpages.
- The script that computes the "value earned" effort hours uses these two files to
  - find all `to_be_checked.yaml checked` commits that were made by an instructor
  - extract the list of accepted tasks from them, and
  - tabulate those tasks and compute the total earned value hours for them.
- That script can also tabulate what the instructor did not accept, which makes practical
  a rule that says a task will only count if it gets accepted no later than upon second (or third?) try.


## `src/*` (outdated, some parts to be taken over to new architecture)

This will map markdown files present in `content` to html files in the target directory `out` in the same directory structure.
Files that are not markdown files will be copied over.

Be aware that starting files with hyperlinks will confuse the meta data plugin.

Custom commands:

* `!toc` will create a table of contents up to a depth of 2. It reads the `title` meta data

   You can provide an additional argument to define the target attribute for the generated links.
   If the provided target is #, the links will instead link to anchors.

* `!subtoc` will do that, but only display the part of the table of contents related to this pat

   This will not include items of a depth that are not included in the main table of content.

* `!inline file` will inline the contents of another file.

   This will _not_ create an html file for that file and it will only work in sub-directories

* `!resources` is just a shortcut for `!inline resources.md`

   Ideally, there will be some option to reference links provided in there in some way

* `!overview folder` inlines folder/overview.md and the title links to folder/index.html

   A `target` meta data in the overview file can override the link target.

* `!tasks` will inline all other files in the same folder

Each inline will be wrapped in its own div, containing a class named after their respective command.

In addition, an optional `src/header.html` and `src/footer.html` will be prepended/appended to each produced html file.

You can define alternative header and footer files on a per file basis via the `header` and `footer` meta data. Please note that this will override both, even if only one of them is provided,

**Usage**

Running main.py will produce the target directory if missing.

If called with the optional argument `clean`, it will remove that directory beforehand.

If called with the optional argument `test`, it will instead run some unit tests
